<!DOCTYPE html>
<html lang="en"><head>
<!-- 2025-01-21 Tue 21:02 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>We Need Better Tools</title>
<meta name="author" content="Sawyer Powell" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="css/index.css"/>
<script defer src="./js/fontawesome/all.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/gruvbox-light-medium.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="./js/index.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Merriweather:ital,wght@0,400;0,700;0,900;1,400;1,700;1,900&family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&display=swap" rel="stylesheet"></head>
<body>
<div class="content">
<div id="sidebar" class="sidebar">
<div class="flex items-center mb-5" onclick="location.href='/'">
<img src="./images/horse.svg" class="shadow-none h-12 rounded-none m-0"/>
<span class="block text-2xl text-fg0 font-bold font-mono ms-2">sawyer-p</span>
</div>
<ul>
<li><a href="about.html">About</a></li>
<li><a href="professional-work.html">Professional Work</a></li>
<hr/>
<li><a href="art.html">Programmatic Art</a></li>
<li><a href="deep-learning.html">Deep Learning</a></li>
<hr/>
<li><a href="posts.html">Posts</a></li>
</ul>
</div>
<div class="org-content">
<h1 class="title">We Need Better Tools</h1>
<img src="https://d1y822qhq55g6.cloudfront.net/default/_superImage/The-Builders.jpg" class="hero">
<div class="status"><p class="author">Written by <a target="_blank" href="https://www.linkedin.com/in/sawyerhpowell/">Sawyer Powell</a> - 2025-01-21 Tue 21:02</p></div>
<img src="./images/tiger.svg" class="justify-self-center shadow-none h-12 rounded-none m-0 mb-5"/>

<div id="outline-container-orgfc38bfb" class="intro">
<div class="outline-text-2" id="text-orgfc38bfb">
<p>
Modern software is is stagnating. Our computers are faster than
ever, we have access to incredibly powerful AI models, but the
experience of using software, especially modern business software, is
painful. Modern software, especially on the web, is incredibly
complicated. Website bundle sizes are, in general, huge. Sometimes
needing to load in <i>megabytes</i> of javascript to run. The modern web
was built to share static documents, this rigidity, combined with
runaway complexity, has made it extremely difficult to deploy truly
extensible and flexible software.
</p>
</div>
</div>

<div id="outline-container-org22e113d" class="outline-2">
<h2 id="org22e113d">Lament</h2>
<div class="outline-text-2" id="text-org22e113d">
<p>
When I first started work after college I was hired as a project
manager at a custom software company called <a href="https://counterpart.biz">Counterpart</a>, which has a
unique approach to software project management. Counterpart operates
entirely on fixed bid, which means the client pays a fixed amount for
each feature, which includes design, development, and testing. The
login and user management systems might be $5,000, a custom content
builder might be $10,000 or so. Each feature of the software is
itemized with an associated price, which forms the total cost of the
project to the client.
</p>

<p>
These items are then scheduled in a pipeline, almost like an assembly
line. Each features starts in the architecture phase, where the whole
team works with the client to fully specify a feature. This then gets
passed to the design mockup phase, where the designer creates renders
with Adobe XD (or Figma), of the feature's UI. These mockups are then
used to create the HTML+CSS, which are then used for development,
which are ultimately tested by the project's tester. Every two weeks a
feature moves to the next phase of the pipeline. This schedule married
with an internal time tracking system helps PMs keep track of what
everyone is doing, which helps update and build out new project
schedules.
</p>

<p>
When I arrived, the company was operating entirely on
spreadsheets. This worked okay, the company only had a couple dozen
employees, but created headaches for us project managers since
information was scattered across Google Drive.
</p>

<p>
If you're in this position, as a person skilled at programming, what
do you do? What options are there? Here's the ones that I thought of:
</p>
<ul class="org-ul">
<li>We can create a custom project management app specifically tailored
to our workflow.
<ul class="org-ul">
<li><b>Pros</b> It will (hopefully) meet all of our needs and relieve
headaches</li>
<li><b>Cons</b> It will create a massive development burden, as well as a
ton of legacy code that will need to change if we ever have to
adapt our business.</li>
</ul></li>
<li>We can try to make use of an off the shelf project management tool
like Asana
<ul class="org-ul">
<li><b>Pros</b> Not much new development work needed</li>
<li><b>Cons</b> We'll have to create hacky systems in the software to
approximate how our business actually works, constantly fighting
it to get it to do what we want. We'll also be at the mercy of a
company who knows nothing about us, who might, at any time, go
belly up or remove critical features.</li>
</ul></li>
<li>We can write a Google Sheets integration which aggregates all of our
data
<ul class="org-ul">
<li><b>Pros</b> Eliminates the problem of having data scattered all over
Google Drive.</li>
<li><b>Cons</b> Doesn't solve the problem of needing custom data-entry
workflows, we're also still tied to displaying information in
spreadsheet form.</li>
<li><i>(This is the option I ended up choosing)</i></li>
</ul></li>
</ul>

<p>
Every option has its tradeoffs, as everything does, but the real issue
is that none of the options above really <i>solve</i> our problem. A real
solution would involve a system that has easy and quick extensibility
and customizability, with the ability to create arbitrary interactions
and visualizations. This is the promise of webapps, so why is our
software so rigid?
</p>

<p>
Web frameworks are in general great at creating modern websites, but
the suck at creating extensible websites. Few people are thinking
about what a truly extensible/customizable website would look
like. I'm looking for something that would allow me to put together a
full project/business management system in a matter of days, rather
than months. One that is <i>fast</i> (i.e. low latency, a criteria almost
all off the shelf solutions fail), and one that preserves its
extensibility, at least relatively well, the more code I write for it.
This doesn't need to be a website, in the loftiest reaches of my
imagination it could be a small component in a fully extensible
computing system.
</p>

<p>
A tool like this <i>can</i> exist, many software projects in the past have
gotten very close. This is the kind of tool that can genuinely
empower everyone who uses a computer, but most people don't understand
that this is a problem, or keep missing the mark. 
</p>
</div>
</div>

<div id="outline-container-orga80fbc9" class="outline-2">
<h2 id="orga80fbc9">Emacs, the POSIX Dream, and Composition</h2>
<div class="outline-text-2" id="text-orga80fbc9">
<p>
Back in the early days of computing extensibility and flexibility were
major philosophical concerns in the study of computing systems. Unix,
and the subsequent POSIX standard, were huge leaps forward in the
design of extensible, and most importantly <i>composable</i>,
systems. Being able to pipe the output of one program into the input
of another allows a programmer to quickly run extremely complex data
transformations using terse syntax. If the computer can't do
something, write a program that combines other programs to achieve
that thing you're trying to do. People love to talk about how to fully
adhere to the Unix Philosophy your software should only do one thing,
and do that thing well. I don't think this is a useful framing. Great
POSIX compliant programs are extremely <i>composable</i>. Composability
should be the primary focus, not how many things your program does.
</p>

<p>
This is part of why there are such big communities of programmers who
are still so enthusiastic about "living on the command line". The
linux shell provides a fully composable, extensible, and most
importantly, <i>turing complete</i> environment for interacting with your
computer. Turing completeness in your environment means the full power
of computing has been preserved going up the chain of
abstraction. Great computing environments <i>always</i> preserve this, they
are an isomorphism of the computer itself.
</p>

<p>
Emacs, perhaps, embodies the farthest extreme of the philosophy of
hyper-extensibility. In Emacs, everything is programmable and
modifiable, with much of that modification made available through an
<code>elisp</code> api. When Emacs works well, its a revelation of what computing
can be. Computers are, at their core, a pile of memory in constant
flux. Text is the simplest way of taking the electrical patterns in
memory and giving them a semantic meaning, with the simplest semantic
being ASCII. For a programmer, living within a realm of pure text
allows them to stay close to the actual computing. Raw text is also
easy to program on top of, because with ASCII and unicode data is
text, text is data. With VI keybindings (provided by Emacs' <i>evil</i>
mode) text not only becomes fast to navigate, but the act of editing
becomes extensible through VI macros. Combining VI bindings with the
ability to write arbitrary (and, importantly, <i>expressive</i>) <code>elisp</code>
macros to do any computing task, Emacs cements itself as one of the
most, if not <i>the</i> most, powerful computing environments in history.
It maintains all the power of a shell interpreter while offering you
more ways to interpret, including powerful facilities for composing
computations in a highly interactive ways.
</p>

<p>
Unfortunately, the platonic ideal of Emacs is often eclipsed by its
reality. Emacs suffers from significant performance problems, and can
have difficulty competing with modern IDEs and editors like Neovim in
providing great code completion and fast syntax highlighting. Emacs'
<code>elisp</code> has many beautiful qualities, as all lisp variants do, but
suffers from a lack of modern programming niceties, like a strong type
system and more modern list/array manipulation syntax like what's
found in Clojure. But, when Emacs is configured carefully, it's fast,
expressive, and extremely powerful. This whole website was written,
compiled to HTML, and deployed entirely using <code>elisp</code> and <a href="https://orgmode.org/">Emacs Org
Mode</a>. No modern web framework needed.
</p>
</div>
</div>
</div>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org22e113d">Lament</a></li>
<li><a href="#orga80fbc9">Emacs, the POSIX Dream, and Composition</a></li>
</ul>
</div>
</div>
</div>
<div class="fixed bottom-10 flex space-x-3"><div id="menu-btn" class="h-12 w-12 p-2 rounded-full bg-aqua text-fg flex justify-center items-center cursor-pointer shadow-lg fill-white 2xl:hidden"><i class="fa-regular fa-bars-sort fa-xl" style="color:white"></i></div><div id="toc-btn" class="h-12 w-12 p-2 rounded-full bg-blue text-fg flex justify-center items-center cursor-pointer shadow-lg fill-white xl:hidden"><i class="fa-regular fa-list-tree fa-xl" style="color:white"></i></div></div></body>
<script>hljs.highlightAll();</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></html>
